# Jirai Kei Library MVP - CoPilot Instructions

## Objective
Build a minimal viable product (MVP) of a **Jirai Kei fashion database website** (similar to LoLibrary), including:
- Browseable item catalog with categories, brands, tags, and images  
- Search and filtering by tags, brand, and category  
- Admin dashboard for adding/editing items  
- Ready for AI enhancement and AWS deployment  

**Target:** MVP in 1 week, deploy to AWS in 2 days under the domain `jiraibrary.org`.

---

## Learning Guideline
**Important:** Since this project is also for learning:
- Always **explain the steps** clearly.
- Provide **reasoning** behind each piece of code or command.
- Include **how/why** each component fits into the overall architecture.
- Avoid giving only “copy-paste” answers; include explanations for learning.

---

## Tech Stack (Updated)

| Layer | Technology | Purpose |
|-------|-------------|----------|
| **Frontend** | **Next.js (React 19)** | Modern, fast UI framework for the website |
| **Backend API** | **Django REST Framework** | Handles data models, admin dashboard, REST endpoints |
| **Database** | **PostgreSQL (AWS RDS)** | Stores brands, tags, items, and metadata |
| **Storage** | **AWS S3** | Image and media file hosting |
| **Deployment** | **AWS Elastic Beanstalk (backend)** + **AWS Amplify / Vercel (frontend)** | Scalable deployment setup |
| **Domain & DNS** | **AWS Route 53 (`jiraibrary.org`)** | Domain management |
| **AI Features (optional)** | CLIP / BLIP / GPT-4o-mini | Tag/category suggestions, auto classification |
| **Auth (future)** | Django Auth / NextAuth.js | For admin & user accounts |

---

## Folder Structure

jiraibrary/
├── backend/ # Django REST API
│ └── requirements.txt
│
├── frontend/ # Next.js project
│ ├── app/ # Next.js 14+ App Router pages
│ ├── components/ # UI components
│ └── package.json
│
└── README.md


Keep a **single GitHub repo** with separated `frontend/` and `backend/` folders.

---

## MVP Features

### 1. Admin Panel
- Add/edit/delete items, brands, tags  
- Upload images to S3  
- Approve items before publishing  

### 2. Frontend (Next.js)
- Browse items by brand, category, or tag  
- Filter + search by keyword or brand  
- Item detail page with image, description, and metadata  

### 3. AI Helper (Optional)
- Auto-suggest tags and category on upload  
- Use CLIP or GPT-based zero-shot tagging  
- Human confirmation before saving  

---

## Week 1 Development Plan

### **Day 1 – Setup**
- Create GitHub repo with two folders: `/backend` and `/frontend`
- Initialize Django project & REST framework
  ```
  pip install django djangorestframework psycopg2 pillow boto3
- Initialize Next.js app
  ```
  npx create-next-app@latest frontend
  → Choose No for React Compiler (for stability)
- Configure PostgreSQL (AWS RDS)
- Commit initial setup

### Day 2 – Models & API

**Define models in Django**
- `Brand`
- `Tag`
- `Item`

**Set up**
- Serializers & REST endpoints (Django REST Framework)
- Connect S3 for image upload (`boto3` + `django-storages`)
- Test CRUD via Django Admin

---

### Day 3 – Next.js UI

**Create pages**
- `/` → Item list with filters
- `/item/[id]` → Item detail
- `/brand/[name]`, `/tag/[name]` → filtered views

**Frontend tasks**
- Use Tailwind CSS for styling
- Fetch data via Axios (or `fetch`) from Django API

---

### Day 4 – Image Upload & AI Integration

**Image upload**
- Integrate AWS S3 image upload in admin (upload + serve from S3)

**AI helper (optional)**
- Add a simple AI tagging helper
  - Script or endpoint that calls OpenAI / CLIP
  - Example flow: send item description + image URL → receive suggested tags
- Present suggestions in admin for human confirmation before saving

---

### Day 5 – Search, Filter, and Polish

- Implement search bar + brand/tag/category filtering
- Add pagination or infinite scroll for long result sets
- Improve visual styling and UI consistency (spacing, fonts, image aspect ratios)

---

### Day 6 – Testing & Debugging

- Test item CRUD in Django Admin
- Test frontend filtering, browsing, and search end-to-end
- Ensure S3-hosted images render correctly in all views
- Prepare production `.env` files and document required environment variables

---

### Day 7 – AWS Deployment

**Backend (Django)**
- Deploy to AWS Elastic Beanstalk (or Lightsail)
- Configure environment variables / secrets
- Connect to AWS RDS (Postgres)
- Ensure static/media handling with S3

**Frontend (Next.js)**
- Deploy to AWS Amplify or Vercel
- Configure `NEXT_PUBLIC_API_BASE_URL` to point to backend API

**Infrastructure to configure**
- AWS RDS (PostgreSQL)
- S3 bucket for media
- Route 53 DNS for `jiraibrary.org`
- HTTPS via AWS Certificate Manager (ACM)

---

## AI Integration (Phase 1)

**Overview**
- Optional but recommended as an admin helper

**Workflow**
1. Admin uploads an image (or links an image URL).
2. Backend sends the image (and optional text) to an AI model (e.g., CLIP, GPT-4o-mini).
3. AI returns suggested tags, categories, or probable brand.
4. Admin reviews & confirms suggestions → saves to database.

**Implementation options**
- Local inference: Hugging Face `transformers` (CLIP/BLIP) for embeddings/captions
- Hosted APIs: OpenAI / Anthropic for captioning and structured extraction

---

## Cost Estimates

| Service                         | Est. Monthly Cost      |
|---------------------------------|------------------------|
| AWS EC2 (Elastic Beanstalk)     | $10–15                |
| AWS RDS (PostgreSQL)            | $10–15                |
| AWS S3                          | $1–5                  |
| Route 53 Domain                 | ~$12 / year           |
| AI API usage                    | Variable (~$5–10 light use) |

---

## Future Roadmap

- AI-assisted image classification & tagging  
- Image similarity / visual search (vector DB: FAISS / Pinecone)  
- Automated web crawling for fashion entries (with human confirmation)  
- Community contributions: user submissions & moderation queue  
- User accounts & favorites system  
- Donation / premium tier to sustain hosting costs

---

## Notes

- Keep MVP focused on **CRUD + browsing + filtering**.  
- AI and auto-crawling are **Phase 2** enhancements.  
- Always document **why** a step or decision is made (learning-first approach).  
- Keep commits small and descriptive to aid learning and rollback.
